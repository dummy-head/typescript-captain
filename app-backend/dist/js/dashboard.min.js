angular
    .module('RDash', ['ui.bootstrap', 'ui.router', 'ngCookies', 'toastr', 'ngAnimate']);

(function () {
    'use strict';

    angular.module("RDash")
        .constant("pageDefinitions", [
            {
                name: 'Dashboard',
                url: '/',
                templateUrl: 'templates/dashboard.html',
                controller: 'DashboardController',
                icon: 'desktop'
            },
            {
                name: 'Monitoring',
                url: '/monitoring',
                templateUrl: 'templates/monitoring.html',
                controller: 'MonitoringCtrl',
                icon: 'tachometer'
            },
            {
                name: 'Apps',
                url: '/apps',
                templateUrl: 'templates/apps.html',
                controller: 'AppDefinitionCtrl',
                icon: 'code'
            },
            {
                name: 'Nodes',
                url: '/nodes',
                templateUrl: 'templates/nodes.html',
                controller: 'NodesInfoCtrl',
                icon: 'server'
            },
            {
                name: 'Settings',
                url: '/settings',
                templateUrl: 'templates/settings.html',
                controller: 'SettingsCtrl',
                icon: 'cogs'
            },
            {
                name: 'Login',
                url: '/login',
                templateUrl: 'templates/login.html',
                controller: 'LoginCtrl',
                isFullPage: true
            }
        ]);

    /**
     * Route configuration for the RDash module.
     */
    angular.module('RDash').config(['$stateProvider', '$urlRouterProvider', 'pageDefinitions',
        function ($stateProvider, $urlRouterProvider, pageDefinitions) {

            // For unmatched routes
            $urlRouterProvider.otherwise('/');

            for (var count = 0; count < pageDefinitions.length; count++) {
                var pageDef = pageDefinitions[count];
                $stateProvider
                    .state(pageDef.name, {
                        url: pageDef.url,
                        templateUrl: pageDef.templateUrl,
                        controller: pageDef.controller
                    });
            }

        }
    ]);

})();

(function(){
    angular.module('RDash')
    .factory('apiManager', ApiManager);

    
    var BASE_API = 'http://captain.captain.x:3000/api/v1/'; // 'http://captain.captain.x/'; 
    var TOKEN_HEADER = 'x-captain-auth';
    var NAMESPACE = 'x-namespace';
    var CAPTAIN = 'captain';
    
    function ApiManager(captainLogger, $http, $timeout) {

        var authToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7Im5hbWVzcGFjZSI6ImNhcHRhaW4iLCJ0b2tlblZlcnNpb24iOiJ0ZXN0In0sImlhdCI6MTUxMDgwMjE5NSwiZXhwIjoxNTQ2ODAyMTk1fQ.ZjDPVMn9Cbk5dV0gw2or-x1jCP0k5jtkMWt7x34p12M';

        function createConfig() {
            var headers = {};
            if (authToken)
                headers[TOKEN_HEADER] = authToken;
            headers[NAMESPACE] = CAPTAIN;
    
            var config = {};
            config.headers = headers;

            // check user/appData or apiManager.uploadAppData before changing this signature.
            return config;
        }
    
        return {
            isLoggedIn: function() {
                return !!authToken;
            },
            logout: function() {
                captainLogger.log('Logging out...');
                authToken = null;
            },
            login: function(password, callback) {
                $http
                    .post(BASE_API + 'login', { password: password }, createConfig())
                    .then(
                        function(response) {
                            var data = response.data;
                            if (data.status === 100) {
                                authToken = data.token;
                            }
                            callback(data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getVersionInfo: function(callback) {
                $http
                    .get(BASE_API + 'user/system/versioninfo', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            changePassword: function (oldPass, newPass, callback) {
                $http
                    .post(BASE_API + 'user/changepassword', {
                        oldPassword: oldPass,
                        newPassword: newPass
                    }, createConfig())
                    .then(
                    function (response) {
                        authToken = null;
                        callback(response.data);
                    },
                    function () {
                        callback(null);
                    });
            },
            performUpdate: function(latestVersion, callback) {
                $http
                    .post(BASE_API + 'user/system/versioninfo', {latestVersion:latestVersion} ,createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getNetDataInfo: function(callback) {
                $http
                    .get(BASE_API + 'user/system/netdata', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            updateNetDataInfo: function(netDataInfo, callback) {
                $http
                    .post(BASE_API + 'user/system/netdata', {netDataInfo:netDataInfo} ,createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getCaptainInfo: function(callback) {
                $http
                    .get(BASE_API + 'user/system/info', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getLoadBalancerInfo: function(callback) {
                $http
                    .get(BASE_API + 'user/system/loadbalancerinfo', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getAllNodes: function(callback) {
                $http
                    .get(BASE_API + 'user/system/nodes/', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            addDockerNode: function(nodeType, privateKey, remoteNodeIpAddress,
                 remoteUserName, captainIpAddress, callback) {
                $http
                    .post(BASE_API + 'user/system/nodes/',{
                        nodeType:nodeType,
                        privateKey:privateKey,
                        remoteNodeIpAddress:remoteNodeIpAddress,
                        remoteUserName:remoteUserName,
                        captainIpAddress:captainIpAddress
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            updateRootDomain: function(rootDomain, callback) {
                $http
                    .post(BASE_API + 'user/system/changerootdomain', { rootDomain: rootDomain }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            enablessl: function(emailAddress, callback) {
                $http
                    .post(BASE_API + 'user/system/enablessl', { emailAddress: emailAddress }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            forceSsl: function(isEnabled, callback) {
                $http
                    .post(BASE_API + 'user/system/forcessl', { isEnabled: isEnabled }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            ensureRegistryHasSsl: function(callback) {
                $http
                    .post(BASE_API + 'user/system/enableregistryssl', {}, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            enableDockerRegistry: function(type, domain, user, password, callback) {
                $http
                    .post(BASE_API + 'user/system/enableregistry', {
                        registryType: type,
                        registryUser: user,
                        registryPassword: password,
                        registryDomain: domain
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            getAllApps: function(callback) {
                $http
                    .get(BASE_API + 'user/appDefinitions/', createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            enableSslForBaseDomain: function(appName, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/enablebasedomainssl', { appName: appName }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            uploadAppData: function(file, appName, callback) {

                var headers = createConfig().headers;
                headers['Content-Type'] = undefined;

                $http({
                    method: 'POST',
                    url: BASE_API + 'user/appData/' + appName,
                    headers: headers,
                    data: {
                        sourceFile: file
                    },
                    transformRequest: function (data, headersGetter) {
                        var formData = new FormData();
                        angular.forEach(data, function (value, key) {
                            formData.append(key, value);
                        });

                        var headers = headersGetter();
                        //delete headers['Content-Type'];

                        return formData;
                    }
                })
                    .success(function (data) {
                        callback(data);
                    })
                    .error(function (serverResp, status) {
                        callback(null);
                    });
            },
            deleteApp: function(appName, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/delete', { 
                        appName: appName
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            registerNewApp: function(appName, hasPersistentData, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/register', { 
                        appName: appName,
                        hasPersistentData: hasPersistentData
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            attachNewCustomDomainToApp: function(appName, newCustomDomain, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/customdomain', { 
                        appName: appName,
                        customDomain: newCustomDomain 
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            enableSslForCustomDomain: function(appName, publicDomain, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/enablecustomdomainssl', { 
                        appName: appName,
                        customDomain: publicDomain 
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            removeCustomDomain: function(appName, publicDomain, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/removecustomdomain', { 
                        appName: appName,
                        customDomain: publicDomain 
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            },
            updateConfigAndSave: function(appName, instanceCount, envVars, 
                notExposeAsWebApp, callback) {
                $http
                    .post(BASE_API + 'user/appDefinitions/update', { 
                        appName: appName,
                        instanceCount: instanceCount,
                        notExposeAsWebApp: notExposeAsWebApp,
                        envVars: envVars
                    }, createConfig())
                    .then(
                        function(response) {
                            callback(response.data);
                        },
                        function() {
                            callback(null);
                        });
            }
        };
    }

}())
angular.module('RDash')
    .run(['$rootScope', '$location', '$state', 'apiManager', 'captainLogger', '$timeout',
        function ($rootScope, $location, $state, apiManager, captainLogger, $timeout) {
            // for some reason stateChangeStart malfunctions... :/
            $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {

                if (!apiManager.isLoggedIn() && toState.url !== '/login') {
                    captainLogger.log('Not authorized : Redirecting to Login');
                    // event.preventDefault();
                    // Redirection doesn't always work if this 1ms delay is removed!
                    $timeout(function () {
                        $location.path('/login');
                    }, 1);
                } else {
                    captainLogger.log('Auth accepted.');
                }
            });

            $rootScope.onLogoutClicked = function () {
                apiManager.logout();
                // Intentionally redirecting to dashboard to get kicked out to login
                // This way we ensure that the user is indeed logged out
                $location.path('/dashboard');
            }
        }
    ])
angular.module('RDash')
    .factory('captainLogger', function($log) {
        return {
            log: function(msg) {
                $log.log('#### ' + msg);
            },

            e: function(msg) {
                $.error('#### ' + msg);
            }
        }

    })
angular.module('RDash')
.factory('captainToast', function(toastr, apiManager) {


            var apiStatusCode = {

                STATUS_OK: 100,

                STATUS_ERROR_GENERIC: 1000,

                STATUS_ERROR_CAPTAIN_NOT_INITIALIZED: 1001,

                STATUS_ERROR_USER_NOT_INITIALIZED: 1101,

                STATUS_ERROR_NOT_AUTHORIZED: 1102,

                STATUS_ERROR_ALREADY_EXIST: 1103,

                STATUS_ERROR_BAD_NAME: 1104,

                STATUS_WRONG_PASSWORD: 1105,

                STATUS_AUTH_TOKEN_INVALID: 1106,

                VERIFICATION_FAILED: 1107

            };
        
            function showToastError(msg) {
                // toastr.warning('Hello world!', 'Toastr fun!');
                toastr.error(msg?msg:'ERROR', 'Error', {
                    "autoDismiss": false,
                    "positionClass": "toast-top-right",
                    "type": "error",
                    "timeOut": "5000",
                    "extendedTimeOut": "2000",
                    "allowHtml": false,
                    "closeButton": false,
                    "tapToDismiss": true,
                    "progressBar": false,
                    "newestOnTop": true,
                    "maxOpened": 0,
                    "preventDuplicates": false,
                    "preventOpenDuplicates": false
                })
            }
    
            function showToastSuccess(msg) {
                toastr.success(msg, '', {
                    "autoDismiss": false,
                    "positionClass": "toast-top-right",
                    "type": "error",
                    "timeOut": "5000",
                    "extendedTimeOut": "2000",
                    "allowHtml": false,
                    "closeButton": false,
                    "tapToDismiss": true,
                    "progressBar": false,
                    "newestOnTop": true,
                    "maxOpened": 0,
                    "preventDuplicates": false,
                    "preventOpenDuplicates": false
                })
            }
    
            return {
                showErrorToastIfNeeded: function(data) {
                    if (!data) {
                        showToastError('Please try again...');
                        return 99999;
                    }
                    if (data && data.status != 100) {
                        // Avoid showing auth token failure errors if there's not token. i.e., fresh page load
                        if (apiManager.isLoggedIn() || data.status !== apiStatusCode.STATUS_AUTH_TOKEN_INVALID) {
                            showToastError(data.description);
                        }
                        return data.status;
                    }
    
                    return null;
                },
                showToastSuccess: function(msg){
                    showToastSuccess(msg);
                },
                showToastError: function(msg){
                    showToastError(msg);
                }
            }
    
        });
/**
 * Alerts Controller
 */

angular
    .module('RDash')
    .controller('AlertsCtrl', ['$scope', AlertsCtrl]);

function AlertsCtrl($scope) {
    $scope.alerts = [{
        type: 'success',
        msg: 'Thanks for visiting! Feel free to create pull requests to improve the dashboard!'
    }, {
        type: 'danger',
        msg: 'Found a bug? Create an issue with as many details as you can.'
    }];

    $scope.addAlert = function() {
        $scope.alerts.push({
            msg: 'Another alert!'
        });
    };

    $scope.closeAlert = function(index) {
        $scope.alerts.splice(index, 1);
    };
}
angular.module('RDash')
    .controller('AppDefinitionCtrl', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$state', AppDefinitionCtrl]);

function AppDefinitionCtrl($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $state) {

    $scope.loadingState = {};
    $scope.loadingState.enabled = true;

    $scope.allApps = null;
    apiManager.getAllApps(function (data) {
        $scope.loadingState.enabled = false;
        if (captainToast.showErrorToastIfNeeded(data)) {
            return;
        }

        $scope.allApps = data.data;

        for (var i = 0; i < data.data.length; i++) {

            var app = data.data[i];

            for (var j = 0; j < app.versions.length; j++) {
                if (app.versions[j].version === app.deployedVersion) {
                    app.deployedGitHash = app.versions[j].gitHash || 'n/a';
                    app.deployedTimeStamp = new Date(app.versions[j].timeStamp).toLocaleString();
                    break;
                }
            }
        }

        $scope.rootDomain = data.rootDomain;

    });

    (function AppDefinitionsContentCtrl() {

        $scope.newAppData = {};

        $scope.onEnableBaseDomainSsl = function (appName) {
            $scope.loadingState.enabled = true;

            apiManager.enableSslForBaseDomain(appName, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                var rootDomain = $scope.rootDomain;

                captainToast.showToastSuccess(
                    'HTTPS is now enabled for your domain at https://'
                    + appName + '.' + rootDomain);
                $state.reload();

            });
        };

        $scope.onCreateNewAppClicked = function () {
            $scope.loadingState.enabled = true;

            var appName = $scope.newAppData.newAppToRegister;
            var hasPersistentData = $scope.newAppData.newAppHasPersistentData;

            apiManager.registerNewApp(appName, hasPersistentData, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                captainToast.showToastSuccess('You new app is registered ' + appName);
                $state.reload();

            });
        };

        $scope.addEnvVarClicked = function (app) {
            app.envVars.push({ key: '', value: '' });
        }

        $scope.onNewCustomDomainClicked = function (appName, newCustomDomain) {
            $scope.loadingState.enabled = true;

            apiManager.attachNewCustomDomainToApp(appName, newCustomDomain, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                captainToast.showToastSuccess('Your new custom domain is attached to the app at http://'
                    + newCustomDomain);
                $state.reload();

            });
        };

        $scope.modalAppDelete = {};
        var modalAppDelete = $scope.modalAppDelete;

        $scope.onDeleteAppClicked = function (appName) {

            $scope.modalAppDelete.appName = appName;
            $scope.modalAppDelete.appNameConfirm = '';

            $uibModal.open({
                animation: true,
                templateUrl: 'templates/modals/delete-app.html',
                controller: function ($scope) {
                    $scope.modalAppDelete = modalAppDelete;
                },
                size: null
            }).result.then(function (returnValue) {

                if (!returnValue)
                    return;

                if ($scope.modalAppDelete.appNameConfirm !== appName) {
                    captainToast.showToastError('App name does not match. Delete cancelled...');
                    return;
                }

                $scope.loadingState.enabled = true;

                apiManager.deleteApp(appName, function (data) {

                    $scope.loadingState.enabled = false;

                    if (captainToast.showErrorToastIfNeeded(data)) {
                        return;
                    }

                    captainToast.showToastSuccess(
                        appName + ' is successfully deleted.');

                    $state.reload();
                });
            });
        };

        $scope.onUploadSourceCodeClicked = function (app) {

            // file to upload is app.sourceToUpload

            console.log(app.sourceToUpload);

            $uibModal.open({
                animation: true,
                templateUrl: 'templates/modals/upload-source.html',
                controller: function ($scope) {
                    $scope.app = app;
                },
                size: null
            }).result.then(function (returnValue) {

                if (!returnValue)
                    return;

                $scope.loadingState.enabled = true;

                apiManager.uploadAppData(app.sourceToUpload, app.appName, function (data) {

                    $scope.loadingState.enabled = false;

                    if (captainToast.showErrorToastIfNeeded(data)) {
                        return;
                    }

                    captainToast.showToastSuccess(
                        app.appName + ' is successfully uploaded & updated.');

                    $state.reload();
                });
            });
        };

        $scope.onEnableCustomDomainSslClicked = function (appName, publicDomain) {
            $scope.loadingState.enabled = true;

            apiManager.enableSslForCustomDomain(appName, publicDomain, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                captainToast.showToastSuccess('HTTPS is now enabled for your domain at https://' + publicDomain);
                $state.reload();

            });
        };

        $scope.onRemoveCustomDomainClicked = function (appName, publicDomain) {
            $scope.loadingState.enabled = true;

            apiManager.removeCustomDomain(appName, publicDomain, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                captainToast.showToastSuccess('You domain is successfully deleted: ' + publicDomain);
                $state.reload();

            });
        };

        $scope.onUpdateConfigAndSave = function (app) {
            $scope.loadingState.enabled = true;

            apiManager.updateConfigAndSave(app.appName, app.instanceCount,
                 app.envVars, app.notExposeAsWebApp, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    return;
                }

                captainToast.showToastSuccess('You app data and configuration is successfully updated.');
                $state.reload();

            });
        };

    }())

}
angular.module('RDash')
    .controller('DashboardController', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$state', '$interval', DashboardController]);

function DashboardController($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $state, $interval) {

    $scope.loadingState = {};
    $scope.captaininfo = {};

    $scope.loadingState.enabled = true;

    apiManager.getCaptainInfo(function (data) {
        $scope.loadingState.enabled = false;
        if (captainToast.showErrorToastIfNeeded(data)) {
            return;
        }

        $scope.captaininfo = data.data;
        $scope.captaininfo.hasCustomDomain = !!data.data.rootDomain;
        $scope.captaininfo.isRegistryLocal = $scope.captaininfo.dockerRegistryDomain.indexOf('registry.' + $scope.captaininfo.rootDomain + ':') === 0;
    });

    /**
     * Root domain controller
     */
    (function DashboardRootdomainCtrl() {

        $scope.onUpdateDomainClicked = function () {
            $scope.loadingState.enabled = true;

            apiManager.updateRootDomain($scope.captaininfo.rootDomain, function (data) {
                $scope.loadingState.enabled = false;

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                $uibModal.open({
                    animation: true,
                    templateUrl: 'templates/modals/simple.html',
                    size: null,
                    controller: function ($scope) {
                        $scope.message = 'Root domain has been successfully updated. Click Ok to get redirected to your new root domain.';
                        $scope.title = 'Success!';
                    }
                }).result.then(function () {
                    // intentionally using replace instead of href to avoid letting user to go back.
                    window.location.replace('http://captain.' + $scope.captaininfo.rootDomain);
                });

            });
        };

        $scope.onForceSslClicked = function () {

            $uibModal.open({
                animation: true,
                templateUrl: 'templates/modals/force-ssl.html',
                size: null
            }).result.then(function (returnValue) {

                if (!returnValue)
                    return;

                $scope.loadingState.enabled = true;

                apiManager.forceSsl(true, function (data) {

                    $scope.loadingState.enabled = false;

                    if (captainToast.showErrorToastIfNeeded(data)) {
                        return;
                    }

                    $uibModal.open({
                        animation: true,
                        templateUrl: 'templates/modals/simple.html',
                        size: null,
                        controller: function ($scope) {
                            $scope.message = 'HTTPS is now being force. Click Ok to get redirected to your secure website.';
                            $scope.title = 'Success!';
                        }
                    }).result
                        .catch(function () { })
                        .then(function () {
                            // intentionally using replace instead of href to avoid letting user to go back.
                            window.location.replace('https://captain.' + $scope.captaininfo.rootDomain);
                        });
                });
            });
        };

        $scope.modaldata = {};
        $scope.modaldata.emailaddress = '';
        var modaldata = $scope.modaldata;

        $scope.onEnableSslClicked = function () {

            $uibModal.open({
                animation: true,
                templateUrl: 'templates/modals/enable-ssl.html',
                size: null,
                controller: function ($scope) {
                    $scope.modaldata = modaldata;
                },
                resolve: {
                    items: function () {
                        return 1;
                    }
                }
            }).result.then(function (err) {
                console.log(err);
                $scope.loadingState.enabled = true;

                apiManager.enablessl($scope.modaldata.emailaddress, function (data) {
                    $scope.loadingState.enabled = false;

                    if (captainToast.showErrorToastIfNeeded(data)) {
                        return;
                    }

                    $uibModal.open({
                        animation: true,
                        templateUrl: 'templates/modals/simple.html',
                        size: null,
                        controller: function ($scope) {
                            $scope.message = 'HTTPS is successfully enabled. Click Ok to get redirected to your secure website.';
                            $scope.title = 'Success!';
                        }
                    }).result.then(function () {
                        // intentionally using replace instead of href to avoid letting user to go back.
                        window.location.replace('https://captain.' + $scope.captaininfo.rootDomain);
                    });
                });
            });
        };
    }());


    /**
     * Registry Controller
     */
    (function DashboardDockerRegistryCtrl() {

        var LOCAL = 'local';
        var REMOTE = 'remote';

        $scope.remote = {};

        var enableDockerRegistry = function (type, domain, user, password) {

            $scope.loadingState.enabled = true;

            apiManager.enableDockerRegistry(type, domain, user, password, function (data) {
                $scope.loadingState.enabled = false;

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                $uibModal.open({
                    animation: true,
                    templateUrl: 'templates/modals/simple.html',
                    size: null,
                    controller: function ($scope) {
                        $scope.message = 'Docker Registry has successfully been updated. IMPORTANT NOTE: it will take up to a minute for you to see this change! Please be patient!';
                        $scope.title = 'Success!';
                    }
                }).result.then(function () {
                    $state.reload();
                });

            });
        }

        $scope.onLocalRegistryClicked = function () {

            $scope.loadingState.enabled = true;

            apiManager.ensureRegistryHasSsl(function (data) {
                $scope.loadingState.enabled = false;

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                enableDockerRegistry(LOCAL);

            });

        };

        $scope.onRemoteRegistryClicked = function () {

            $scope.loadingState.enabled = true;

            console.log($scope)

            enableDockerRegistry(REMOTE,
                $scope.remote.domain,
                $scope.remote.username,
                $scope.remote.password);

        };

    }());

}
angular.module('RDash')
    .controller('LoginCtrl', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$location', '$state', LoginCtrl]);

function LoginCtrl($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $location, $state) {

    $scope.data = {};

    $scope.onLoginClicked = function () {
        apiManager.login($scope.data.captainPassword, function (data) {
            if (captainToast.showErrorToastIfNeeded(data)) {
                return;
            }
            $location.path('/dashboard');
        });
    }

}
/**
 * Master Controller
 */

angular.module('RDash')
    .controller('MasterCtrl', ['$scope', '$cookieStore', '$rootScope', 'pageDefinitions', 
    '$location', 'apiManager', MasterCtrl]);

function MasterCtrl($scope, $cookieStore, $rootScope, pageDefinitions
    , $location, apiManager) {

    $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
        $scope.routePath = toState.url;
        $scope.pageName = '';
        for (var count = 0; count < pageDefinitions.length; count++) {
            if (pageDefinitions[count].url == toState.url){
                $scope.pageName = pageDefinitions[count].name;
                $scope.isFullPage = pageDefinitions[count].isFullPage;
            }
        }
    });

    $scope.onLogoutClicked = function(){
        apiManager.logout();
        $location.path('/login');
    }

    /**
     * Sidebar Toggle & Cookie Control
     */
    var mobileView = 992;

    $scope.getWidth = function () {
        return window.innerWidth;
    };

    $scope.pageDefinitions = [];

    for (var i = 0; i < pageDefinitions.length; i++) {
        if (pageDefinitions[i].icon){
            $scope.pageDefinitions.push(pageDefinitions[i]);
        }
    }

    $scope.$watch($scope.getWidth, function (newValue, oldValue) {
        if (newValue >= mobileView) {
            if (angular.isDefined($cookieStore.get('toggle'))) {
                $scope.toggle = !$cookieStore.get('toggle') ? false : true;
            } else {
                $scope.toggle = true;
            }
        } else {
            $scope.toggle = false;
        }

    });

    $scope.toggleSidebar = function () {
        $scope.toggle = !$scope.toggle;
        $cookieStore.put('toggle', $scope.toggle);
    };

    window.onresize = function () {
        $scope.$apply();
    };
}
angular.module('RDash')
    .controller('MonitoringCtrl', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$state', '$interval', MonitoringController]);

function MonitoringController($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $state, $interval) {

    $scope.loadingState = {};
    $scope.captaininfo = {};

    $scope.loadingState.enabled = true;

    function fetchLoadBalancerInfo() {
        apiManager.getLoadBalancerInfo(function (data) {
            $scope.loadBalancerInfo = null;
            if (captainToast.showErrorToastIfNeeded(data)) {
                return;
            }
            $scope.loadBalancerInfo = data.data;
        });
    }

    var promise = $interval(fetchLoadBalancerInfo, 30000);
    $scope.$on('$destroy', function () {
        $interval.cancel(promise);
    });

    apiManager.getNetDataInfo(function (data) {
        $scope.loadingState.enabled = false;
        if (captainToast.showErrorToastIfNeeded(data)) {
            return;
        }
                
        fetchLoadBalancerInfo();
        $scope.netDataInfo = data.data;
    });

    /**
     * Root domain controller
     */
    (function DashboardRootdomainCtrl() {

        var updateNetData = function (setIsEnabledIfFailed) {
            apiManager.updateNetDataInfo($scope.netDataInfo, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    $scope.loadingState.enabled = false;
                    $scope.netDataInfo.isEnabled = setIsEnabledIfFailed;
                    return;
                }
                
                var isBeingEnabled = $scope.netDataInfo.isEnabled;

                $uibModal.open({
                    animation: true,
                    templateUrl: 'templates/modals/simple.html',
                    size: null,
                    controller: function ($scope) {

                        $scope.message = isBeingEnabled ?
                            'NetData is successfully updated.' : 'NetData is turned off.';
                        $scope.title = 'Success!';
                    }
                }).result.then(function () {
                    $state.reload();
                });

            });
        }

        $scope.onStartNetDataClicked = function () {
            $scope.loadingState.enabled = true;
            $scope.netDataInfo.isEnabled = true;
            updateNetData(false);
        };

        $scope.onStopNetDataClicked = function () {
            $scope.loadingState.enabled = true;
            $scope.netDataInfo.isEnabled = false;
            updateNetData(true);
        };

        $scope.onUpdateNetDataClicked = function () {
            $scope.loadingState.enabled = true;
            updateNetData(true);
        };

    }());

}
angular.module('RDash')
    .controller('NodesInfoCtrl', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$state', NodesInfoCtrl]);

function NodesInfoCtrl($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $state) {

    $scope.loadingState = {};
    $scope.loadingState.enabled = true;

    $scope.allNodes = null;
    apiManager.getAllNodes(function (data) {
        $scope.loadingState.enabled = false;
        if (captainToast.showErrorToastIfNeeded(data)) {
            return;
        }

        $scope.allNodes = data.data;
    });

    (function NodesInfoContentCtrl() {

        $scope.nodeToAdd = {
            remoteUserName: 'root'
        };

        $scope.onAddNodeClicked = function () {
            $scope.loadingState.enabled = true;

            var nodeToAdd = $scope.nodeToAdd;

            apiManager.addDockerNode(nodeToAdd.nodeType, nodeToAdd.privateKey, nodeToAdd.remoteNodeIpAddress,
                nodeToAdd.remoteUserName, nodeToAdd.captainIpAddress, function (data) {

                    if (captainToast.showErrorToastIfNeeded(data)) {
                        $scope.loadingState.enabled = false;
                        return;
                    }

                    captainToast.showToastSuccess('Your new node is successfully added to your cluster.');
                    $state.reload();

                });
        };

    }());

}
angular.module('RDash')
    .controller('SettingsCtrl', ['$scope', '$cookieStore',
        '$rootScope', 'pageDefinitions', 'apiManager', 'captainToast',
        '$uibModal', '$state', SettingsCtrl]);

function SettingsCtrl($scope, $cookieStore, $rootScope, pageDefinitions,
    apiManager, captainToast, $uibModal, $state) {

    $scope.loadingState = {};
    $scope.passwords = {};

    (function ChangePasswordCtrl() {

        $scope.onChangePasswordClicked = function () {
            $scope.loadingState.enabled = true;
            apiManager.changePassword($scope.passwords.oldPass, $scope.passwords.newPass, function (data) {

                $scope.loadingState.enabled = false;

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                captainToast.showToastSuccess('Password is changed...');

                $state.reload();
            });
        }
    }());

    (function UpdateCaptainCtrl() {

        function checkForUpdate() {
            $scope.loadingState.enabled = true;
            apiManager.getVersionInfo(function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                $scope.loadingState.enabled = false;
                $scope.versionInfo = data.data;

            });
        }

        checkForUpdate();

        $scope.onCheckForUpdatesClicked = function () {
            checkForUpdate();
        }

        $scope.onPerformUpdateClicked = function () {
            $scope.loadingState.enabled = true;
            apiManager.performUpdate($scope.versionInfo.latestVersion, function (data) {

                if (captainToast.showErrorToastIfNeeded(data)) {
                    return;
                }

                captainToast.showToastSuccess('Update process has successfully started...');

                $scope.loadingState.enabled = false;

            });
        }

    }());

}
/**
 * File Upload Read Directive
 */

angular
    .module('RDash')
    .directive("fileread", [function () {
        return {
            scope: {
                fileread: "="
            },
            link: function (scope, element, attributes) {
                element.bind("change", function (changeEvent) {
                    scope.$apply(function () {
                        scope.fileread = changeEvent.target.files[0];
                        // or all selected files:
                        // scope.fileread = changeEvent.target.files;
                    });
                });
            }
        }
    }]);
/**
 * Loading Directive
 * @see http://tobiasahlin.com/spinkit/
 */

angular
    .module('RDash')
    .directive('rdLoading', rdLoading);

function rdLoading() {
    var directive = {
        restrict: 'AE',
        template: '<div class="loading"><div class="double-bounce1"></div><div class="double-bounce2"></div></div>'
    };
    return directive;
};
/**
 * Widget Body Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetBody', rdWidgetBody);

function rdWidgetBody() {
    var directive = {
        requires: '^rdWidget',
        scope: {
            loading: '=?',
            classes: '@?'
        },
        transclude: true,
        template: '<div class="widget-body" ng-class="classes"><rd-loading ng-show="loading"></rd-loading><div ng-hide="loading" class="widget-content" ng-transclude></div></div>',
        restrict: 'E'
    };
    return directive;
};

/**
 * Widget Footer Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetFooter', rdWidgetFooter);

function rdWidgetFooter() {
    var directive = {
        requires: '^rdWidget',
        transclude: true,
        template: '<div class="widget-footer" ng-transclude></div>',
        restrict: 'E'
    };
    return directive;
};
/**
 * Widget Header Directive
 */

angular
    .module('RDash')
    .directive('rdWidgetHeader', rdWidgetTitle);

function rdWidgetTitle() {
    var directive = {
        requires: '^rdWidget',
        scope: {
            title: '@',
            icon: '@'
        },
        transclude: true,
        template: '<div class="widget-header"><div class="row"><div class="pull-left"><i class="fa" ng-class="icon"></i> {{title}} </div><div class="pull-right col-xs-6 col-sm-4" ng-transclude></div></div></div>',
        restrict: 'E'
    };
    return directive;
};
/**
 * Widget Directive
 */

angular
    .module('RDash')
    .directive('rdWidget', rdWidget);

function rdWidget() {
    var directive = {
        transclude: true,
        template: '<div class="widget" ng-transclude></div>',
        restrict: 'EA'
    };
    return directive;

    function link(scope, element, attrs) {
        /* */
    }
};